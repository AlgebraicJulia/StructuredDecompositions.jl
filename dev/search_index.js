var documenterSearchIndex = {"docs":
[{"location":"api/FunctorUtils/#FunctorUtils","page":"FunctorUtils","title":"FunctorUtils","text":"","category":"section"},{"location":"api/FunctorUtils/","page":"FunctorUtils","title":"FunctorUtils","text":"Modules = [StructuredDecompositions.FunctorUtils]","category":"page"},{"location":"pages/FunctorUtils/#FunctorUtils","page":"FunctorUtils","title":"Functor Utils","text":"","category":"section"},{"location":"pages/FunctorUtils/","page":"FunctorUtils","title":"FunctorUtils","text":"Functor Utils only includes 4 functions and builds off of Decompositions.","category":"page"},{"location":"pages/FunctorUtils/","page":"FunctorUtils","title":"FunctorUtils","text":"We first define the forgetful functors vs.","category":"page"},{"location":"pages/FunctorUtils/","page":"FunctorUtils","title":"FunctorUtils","text":"function vs(X::Graph) FinSet(length(vertices(X))) end\nfunction vs(f::ACSetTransformation) components(f)[1] end","category":"page"},{"location":"pages/FunctorUtils/","page":"FunctorUtils","title":"FunctorUtils","text":"We also define the functor skeleton taking set to the skeleton of the set.","category":"page"},{"location":"pages/FunctorUtils/","page":"FunctorUtils","title":"FunctorUtils","text":"function skeleton(s::FinSet) FinSet(length(s)) end\nfunction skeleton(f::FinFunction)\n  (dd, cc) = (dom(f), codom(f))\n  ‚Ñì = isempty(dd) ? Int[] : [findfirst(item -> item == f(x), collect(cc)) for x ‚àà collect(dd)]\n  FinFunction(‚Ñì, skeleton(dd), skeleton(cc))\nend","category":"page"},{"location":"api/DecidingSheaves/#DecidingSheaves","page":"DecidingSheaves","title":"DecidingSheaves","text":"","category":"section"},{"location":"api/DecidingSheaves/","page":"DecidingSheaves","title":"DecidingSheaves","text":"Modules = [StructuredDecompositions.DecidingSheaves]","category":"page"},{"location":"api/DecidingSheaves/#StructuredDecompositions.DecidingSheaves.decide_sheaf_tree_shape","page":"DecidingSheaves","title":"StructuredDecompositions.DecidingSheaves.decide_sheaf_tree_shape","text":"Solve the decision problem encoded by a sheaf.  The algorithm is as follows:    compute on each bag    (optionally, if the decomposition of the solution space   is already known, then it can be passed as an argument),   compute composites on edges,    project back down to bags   answer (providing a witness)     \"no\" if there is an empty bag;      \"yes\" otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/Decompositions/#Decompositions","page":"Decompositions","title":"Decompositions","text":"","category":"section"},{"location":"api/Decompositions/","page":"Decompositions","title":"Decompositions","text":"Modules = [StructuredDecompositions.Decompositions]","category":"page"},{"location":"api/Decompositions/#StructuredDecompositions.Decompositions.StrDecomp","page":"Decompositions","title":"StructuredDecompositions.Decompositions.StrDecomp","text":"Structured decomposition struct     ‚Äì Consider these as graphs whose vertices are labeled by the objects of some category      and whose edges are labeled by spans in this category\n\n\n\n\n\n","category":"type"},{"location":"api/Decompositions/#StructuredDecompositions.Decompositions.StrDecomp-Tuple{Any, Any}","page":"Decompositions","title":"StructuredDecompositions.Decompositions.StrDecomp","text":"One can construct a structured decomposition by simply providing the graph representing the shape of the decompostion and the relevant diagram. This constructor will default to setting the Decompsotion Type to Decomposition (i.e. we default to viewing C-valued structured decompositions as diagrams into Span C)\n\n\n\n\n\n","category":"method"},{"location":"api/Decompositions/#StructuredDecompositions.Decompositions.StrDecomp-Tuple{Catlab.Graphs.BasicGraphs.HasGraph}","page":"Decompositions","title":"StructuredDecompositions.Decompositions.StrDecomp","text":"StrDecomp(graph::HasGraph;\n    alg::PermutationOrAlgorithm=DEFAULT_ELIMINATION_ALGORITHM,\n    snd::SupernodeType=DEFAULT_SUPERNODE_TYPE)\n\nConstruct a structured decomposition of a simple graph.\n\n\n\n\n\n","category":"method"},{"location":"api/Decompositions/#StructuredDecompositions.Decompositions.StructuredDecomposition","page":"Decompositions","title":"StructuredDecompositions.Decompositions.StructuredDecomposition","text":"Structured decompositions are diagrams.\n\n\n\n\n\n","category":"type"},{"location":"api/Decompositions/#StructuredDecompositions.Decompositions.adhesionSpans-Tuple{Any, Any}","page":"Decompositions","title":"StructuredDecompositions.Decompositions.adhesionSpans","text":"Get a vector of indexed adhesion spans; i.e. a vector consisting of pairs (x‚ÇÅ <- e -> x‚ÇÇ, dx‚ÇÅ <- de -> dx‚ÇÇ) where x‚ÇÅ <- e -> x‚ÇÇ is span in ‚à´G and dx‚ÇÅ <- de -> dx‚ÇÇ is what its image under the decompositon d\n\n\n\n\n\n","category":"method"},{"location":"api/Decompositions/#StructuredDecompositions.Decompositions.adhesionSpans-Tuple{Any}","page":"Decompositions","title":"StructuredDecompositions.Decompositions.adhesionSpans","text":"Get a vector of the adhesion spans of a decomposition\n\n\n\n\n\n","category":"method"},{"location":"api/Decompositions/#StructuredDecompositions.Decompositions.adhesions-Tuple{Any, Any}","page":"Decompositions","title":"StructuredDecompositions.Decompositions.adhesions","text":"Get a vector of indexed adhesions; i.e. a vector consisting of pairs (e, de) where e is an edge in ‚à´G and de is the value mapped to e under the decompositon d\n\n\n\n\n\n","category":"method"},{"location":"api/Decompositions/#StructuredDecompositions.Decompositions.adhesions-Tuple{Any}","page":"Decompositions","title":"StructuredDecompositions.Decompositions.adhesions","text":"Get a vector of the adhesions of a decomposition\n\n\n\n\n\n","category":"method"},{"location":"api/Decompositions/#StructuredDecompositions.Decompositions.bags-Tuple{Any, Any}","page":"Decompositions","title":"StructuredDecompositions.Decompositions.bags","text":"Get a vector of indexed bags; i.e. a vector consisting of pairs (x, dx) where x ‚àà FG and dx is the value mapped to x under the decompositon d\n\n\n\n\n\n","category":"method"},{"location":"api/Decompositions/#StructuredDecompositions.Decompositions.bags-Tuple{Any}","page":"Decompositions","title":"StructuredDecompositions.Decompositions.bags","text":"Get a vector of the bags of a decomposition\n\n\n\n\n\n","category":"method"},{"location":"api/Decompositions/#StructuredDecompositions.Decompositions.‚à´-Tuple{T} where T<:ACSets.ACSetInterface.ACSet","page":"Decompositions","title":"StructuredDecompositions.Decompositions.‚à´","text":"Syntactic sugar for costructing the category of elements of a graph.  Note that ‚à´(G) has type Category whereas elements(G) has type Elements\n\n\n\n\n\n","category":"method"},{"location":"api/Decompositions/#StructuredDecompositions.Decompositions.ùêÉ","page":"Decompositions","title":"StructuredDecompositions.Decompositions.ùêÉ","text":"The construction of categories of structured decompostions is functorial;  it consists of a functor ùêÉ: Cat{pullback} ‚Üí Cat taking any category C with pullbacks to the category  ùêÉC of C-values structured decompositions. The functoriality of this construction allows us to lift any functor  F : C ‚Üí E to a functor ùêÉf : ùêÉ C ‚Üí ùêÉ E which maps C-valued structured decompositions to E-valued structured decompositions.  When we think of the functor F as a computational problem (taking inputs in C to solution spaces in E), then ùêÉf should be thought of as lifting the global comuputation of F to local computation on the constituent parts of C-valued decompositions.  In particular, given a structured decomposition d: FG ‚Üí C and a sheaf F: C ‚Üí FinSet^{op} w.r.t to the decompositon topology,  we can make a structured decomposition valued in FinSet^{op} by lifting the sheaf to a functor ùêÉf: ùêÉC ‚Üí ùêÉ(S^{op}) between  categories of structured decompositions. \n\n\n\n\n\n","category":"function"},{"location":"pages/Decompositions/#Decompositions","page":"Decompositions","title":"Decompositions","text":"","category":"section"},{"location":"pages/Decompositions/","page":"Decompositions","title":"Decompositions","text":"Structured decompositions are diagrams. They can be thought of as graphs whose vertices are labeled by the objects of some category and whose edges are labeld by spans in this category. ","category":"page"},{"location":"pages/Decompositions/","page":"Decompositions","title":"Decompositions","text":"abstract type StructuredDecomposition{G, C, D} <: Diagram{id, C, D} end\n\nstruct StrDecomp{G, C, D} <: StructuredDecomposition{G, C, D}  \n  decomp_shape ::G \n  diagram      ::D             \n  decomp_type  ::DecompType\n  domain       ::C  \nend","category":"page"},{"location":"pages/Decompositions/","page":"Decompositions","title":"Decompositions","text":"A structured decomposition can be constructed by providing the graph representing the shap of the decomposition and the relevant diagram. The default constructor will set the decomposition type to Decomposition (viewing C-valued structured decompositions as diagrams into Span C).","category":"page"},{"location":"pages/Decompositions/","page":"Decompositions","title":"Decompositions","text":"StrDecomp(the_decomp_shape, the_diagram)=StrDecomp(the_decomp_shape, the_diagram, Decomposition)","category":"page"},{"location":"pages/Decompositions/","page":"Decompositions","title":"Decompositions","text":"The function StrDecomp will construct a structured decomposition and check whether the decomposition shape makes sense.","category":"page"},{"location":"pages/Decompositions/","page":"Decompositions","title":"Decompositions","text":"StrDecomp(the_decomp_shape, the_diagram, the_decomp_type)","category":"page"},{"location":"pages/Decompositions/","page":"Decompositions","title":"Decompositions","text":"The functions colimit and limit when called on a structured decomposition will take the colimit and limit of the diagram, respectively.","category":"page"},{"location":"pages/Decompositions/","page":"Decompositions","title":"Decompositions","text":"function colimit(d::StructuredDecomposition) colimit(FreeDiagram(d.diagram)) end\nfunction limit(d::StructuredDecomposition) limit(FreeDiagram(d.diagram)) end","category":"page"},{"location":"pages/Decompositions/","page":"Decompositions","title":"Decompositions","text":"The construction of categories of structured decompositions consists of a functor ùêÉ:Cat_{pullback} ‚Üí Cat taking any category C to the category ùêÉC of C-valued structured decompositions. This allows the lifting of any functor F: C ‚Üí E to a functor ùêÉf : ùêÉC ‚Üí ùêÉE which maps C-valued structured decompositions to E-valued structured decompostions.","category":"page"},{"location":"pages/Decompositions/","page":"Decompositions","title":"Decompositions","text":"function ùêÉ(f, d ::StructuredDecomposition, t::DecompType = d.decomp_type)::StructuredDecomposition","category":"page"},{"location":"pages/DecidingSheaves/#DecidingSheaves","page":"DecidingSheaves","title":"Deciding Sheaves","text":"","category":"section"},{"location":"pages/DecidingSheaves/","page":"DecidingSheaves","title":"DecidingSheaves","text":"There are two functions that are used here. ","category":"page"},{"location":"pages/DecidingSheaves/","page":"DecidingSheaves","title":"DecidingSheaves","text":"The first one called adhesion_filter will take an input Finset^{op}-valued structured decomposition and return a new structured decompostion replacing the span de in d by the span obtained by projecting the pullback of de. ","category":"page"},{"location":"pages/DecidingSheaves/","page":"DecidingSheaves","title":"DecidingSheaves","text":"function adhesion_filter(tup::Tuple, d::StructuredDecomposition)","category":"page"},{"location":"pages/DecidingSheaves/","page":"DecidingSheaves","title":"DecidingSheaves","text":"The second function is called decidesheaftree_shape and solves a decision problem that is encoded by a sheaf. This function works by computing first on each of the bags, then computes composites on edges and projects back down to bags.","category":"page"},{"location":"pages/DecidingSheaves/","page":"DecidingSheaves","title":"DecidingSheaves","text":"function decide_sheaf_tree_shape(f, d::StructuredDecomposition, solution_space_decomp::StructuredDecomposition = ùêÉ(f, d, CoDecomposition))","category":"page"},{"location":"pages/DecidingSheaves/#Graph-Coloring-Structure-and-Examples","page":"DecidingSheaves","title":"Graph Coloring Structure and Examples","text":"","category":"section"},{"location":"pages/DecidingSheaves/","page":"DecidingSheaves","title":"DecidingSheaves","text":"One of the many decision problems that can be solved using this system of functions is figuring out graph colorings. To put it simply, a graph coloring is an assignment of labels(colors) to each vertex of a graph so that no two adjacent vertices have the same label(color).","category":"page"},{"location":"pages/DecidingSheaves/","page":"DecidingSheaves","title":"DecidingSheaves","text":"We first define the structure of a coloring.","category":"page"},{"location":"pages/DecidingSheaves/","page":"DecidingSheaves","title":"DecidingSheaves","text":"#an H-coloring is a hom onto H\nstruct Coloring\n  n     #the target graph\n  func  #the function mapping opens to lists of homs from G to K_n\nend","category":"page"},{"location":"pages/DecidingSheaves/","page":"DecidingSheaves","title":"DecidingSheaves","text":"We then define how we are going to create and test colorings.","category":"page"},{"location":"pages/DecidingSheaves/","page":"DecidingSheaves","title":"DecidingSheaves","text":"#construct an n-coloring\nK(n) = complete_graph(Graph, n)\nColoring(n) = Coloring(n, g -> homomorphisms(g, K(n) ))\n#make it callable\n(c::Coloring)(X::Graph) = FinSet(c.func(X)) # given graph homos #f: G‚ÇÅ ‚Üí G‚ÇÇ get morphism col(G‚ÇÇ) ‚Üí col(G‚ÇÅ) by precomposition: take each Œª‚ÇÇ ‚àà col(G‚ÇÇ) to hf ‚àà col(G)\nfunction (c::Coloring)(f::ACSetTransformation)  \n  (G‚ÇÅ, G‚ÇÇ)   = (dom(f), codom(f)) \n  (cG‚ÇÅ, cG‚ÇÇ) = (c(G‚ÇÅ), c(G‚ÇÇ))\n  FinFunction( Œª‚ÇÇ -> compose(f,Œª‚ÇÇ), cG‚ÇÇ, cG‚ÇÅ ) #note the contravariance\nend\n\nskeletalColoring(n) = skeleton ‚àò Coloring(n)\n\ncolorability_test(n, the_test_case) = is_homomorphic(ob(colimit(the_test_case)), K(n)) == decide_sheaf_tree_shape(skeletalColoring(n), the_test_case)[1]","category":"page"},{"location":"pages/DecidingSheaves/","page":"DecidingSheaves","title":"DecidingSheaves","text":"We can consider the example of a ring with seven nodes as our graph.  We first seperate the nodes into bags with adhesions and what our adhesions look like.","category":"page"},{"location":"pages/DecidingSheaves/","page":"DecidingSheaves","title":"DecidingSheaves","text":"#bag 1\nH‚ÇÅ = @acset Graph begin\n    V = 3\n    E = 2\n    src = [1, 2]\n    tgt = [2, 3]\nend\n\n#adhesion 1,2\nH‚ÇÅ‚ÇÇ = @acset Graph begin\n    V = 2\nend\n\n#bag 2\nH‚ÇÇ = @acset Graph begin\n    V = 4\n    E = 3\n    src = [1, 2, 3]\n    tgt = [2, 3, 4]\nend\n\nG‚Çõ = @acset Graph begin\n    V = 2\n    E = 1\n    src = [1]\n    tgt = [2]\nend","category":"page"},{"location":"pages/DecidingSheaves/","page":"DecidingSheaves","title":"DecidingSheaves","text":"We can then construct our structured decomposition through transformations of these bags and adhesions.","category":"page"},{"location":"pages/DecidingSheaves/","page":"DecidingSheaves","title":"DecidingSheaves","text":"#transformations\nŒì‚Çõ‚Å∞ = Dict(1 => H‚ÇÅ, 2 => H‚ÇÇ, 3 => H‚ÇÅ‚ÇÇ)\nŒì‚Çõ = FinDomFunctor(\n    Œì‚Çõ‚Å∞,\n    Dict(\n      1 => ACSetTransformation(Œì‚Çõ‚Å∞[3], Œì‚Çõ‚Å∞[1], V=[1, 3]),\n      2 => ACSetTransformation(Œì‚Çõ‚Å∞[3], Œì‚Çõ‚Å∞[2], V=[4, 1]),\n    ),\n    ‚à´(G‚Çõ)\n)\n\nmy_decomp1  = StrDecomp(G‚Çõ, Œì‚Çõ)","category":"page"},{"location":"#StructuredDecompositions.jl","page":"StructuredDecompositions.jl","title":"StructuredDecompositions.jl","text":"","category":"section"},{"location":"","page":"StructuredDecompositions.jl","title":"StructuredDecompositions.jl","text":"CurrentModule = StructuredDecompositions","category":"page"},{"location":"","page":"StructuredDecompositions.jl","title":"StructuredDecompositions.jl","text":"Structural graph theorists and algorithmicists alike know that it's usually a smart idea to decompose graphs into smaller and simpler parts before trying answer difficult computational questions. Tree decompositions are one of the best-known ways of systematically chopping graphs up and, as such they have been key tools for establishing deep results in many areas of discrete mathematics including graph minor theory and algorithmic meta-theorems. ","category":"page"},{"location":"#Generality","page":"StructuredDecompositions.jl","title":"Generality","text":"","category":"section"},{"location":"","page":"StructuredDecompositions.jl","title":"StructuredDecompositions.jl","text":"This project consists of an implementation of the category-theoretic notion of structured decompositions. These provide a formalism for decomposing arbitrary mathematical objects (not just graphs) and morphisms between them into smaller constituent parts. Since the definition of a structured decompositions is functorial, one can easily lift computational problems (defined as functors mapping inputs to solution spaces) to functors between from decompositions of the inputs to decompositions of solution spaces.","category":"page"},{"location":"#What-is-in-this-package?","page":"StructuredDecompositions.jl","title":"What is in this package?","text":"","category":"section"},{"location":"","page":"StructuredDecompositions.jl","title":"StructuredDecompositions.jl","text":"This package allows one to leverage insights to solve decision problems that are encoded as sheaves efficiently (i.e. in fixed-parameter-tractable time parameterized by the width of the decompositions). Currently, this packages includes many general tools that can be used to decompose arbitrary mathematical objects. One of the many applications of this package, exampled in the Deciding Sheaves module, is graph colorings.","category":"page"},{"location":"","page":"StructuredDecompositions.jl","title":"StructuredDecompositions.jl","text":"Pages = [\n    \"pages/decompostions.md\",\n    \"pages/decidingsheaves.md\",\n    \"pages/functor_utils.md\",\n    ]\nDepth = 2","category":"page"}]
}
